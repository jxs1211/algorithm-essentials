https://labuladong.github.io/algo/
每日打卡

#### BT

二叉树解题的思维模式分两类：

1、前序遍历：是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现，这叫「遍历」的思维模式。

2、后序分解：是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。

无论使用哪种思维模式，你都需要思考：

如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

#### DP

```golang
# 自顶向下递归的动态规划
def dp(状态1, 状态2, ...):
    for 选择 in 所有可能的选择:
        # 此时的状态已经因为做了选择而改变
        result = 求最值(result, dp(状态1, 状态2, ...))
    return result

# 自底向上迭代的动态规划
# 初始化 base case
dp[0][0][...] = base case
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)

```

递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间。

千万不要看不起暴力解，动态规划问题最困难的就是写出这个暴力解，即状态转移方程。

最优子结构
消除重复子问题：
要符合「最优子结构」，子问题间必须互相独立，互不干扰。

如何列出正确的状态转移方程：
步骤：
1 base case
2 确认状态
3 确认选择
4 确定状态转移方程

例子：
1、确定 base case，这个很简单，显然目标金额 amount 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。

2、确定「状态」，也就是原问题和子问题中会变化的变量。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 amount。

3、确定「选择」，也就是导致「状态」产生变化的行为。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。

4、明确 dp 函数/数组的定义。我们这里讲的是自顶向下的解法，所以会有一个递归的 dp 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。

所以我们可以这样定义 dp 函数：dp(n) 表示，输入一个目标金额 n，返回凑出目标金额 n 所需的最少硬币数量。

**在阅读每个题目和解法时，多往「状态」和「选择」上靠，才能对这套框架产生自己的理解，运用自如。**

但反过来，最优子结构性质作为动态规划问题的必要条件，一定是让你求最值的

二、如何一眼看出重叠子问题

首先，最简单粗暴的方式就是画图，把递归树画出来，看看有没有重复的节点。

但稍加思考就可以知道，其实根本没必要画图，可以通过递归框架直接判断是否存在重叠子问题。

```golang
func dp(grid int[][], i, j int) int {
    dp(grid, i - 1, j), // #1
    dp(grid, i, j - 1)  // #2
}
```
i, j 的值在不断变化（减小），那么我问你一个问题：如果我想从状态 (i, j) 转移到 (i-1, j-1)，有几种路径？

显然有两种路径，可以是 (i, j) -> #1 -> #2 或者 (i, j) -> #2 -> #1，**不止一种，说明 (i-1, j-1) 会被多次计算，所以一定存在重叠子问题。**


四、dp 数组的遍历方向

1、遍历的过程中，所需的状态必须是已经计算出来的。

2、遍历结束后，存储结果的那个位置必须已经被计算出来。


动态规划之子序列问题解题模板![https://labuladong.github.io/algo/3/26/79/]